// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: messages.proto

#ifndef PROTOBUF_messages_2eproto__INCLUDED
#define PROTOBUF_messages_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3003000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3003000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "xmr.pb.h"
#include "command.pb.h"
#include <google/protobuf/timestamp.pb.h>
// @@protoc_insertion_point(includes)
namespace cauchy {
class CommandRequest;
class CommandRequestDefaultTypeInternal;
extern CommandRequestDefaultTypeInternal _CommandRequest_default_instance_;
class CommandStatusReply;
class CommandStatusReplyDefaultTypeInternal;
extern CommandStatusReplyDefaultTypeInternal _CommandStatusReply_default_instance_;
class Config;
class ConfigDefaultTypeInternal;
extern ConfigDefaultTypeInternal _Config_default_instance_;
class Connection;
class ConnectionDefaultTypeInternal;
extern ConnectionDefaultTypeInternal _Connection_default_instance_;
class DifficultyChange;
class DifficultyChangeDefaultTypeInternal;
extern DifficultyChangeDefaultTypeInternal _DifficultyChange_default_instance_;
class Empty;
class EmptyDefaultTypeInternal;
extern EmptyDefaultTypeInternal _Empty_default_instance_;
class End;
class EndDefaultTypeInternal;
extern EndDefaultTypeInternal _End_default_instance_;
class Error;
class ErrorDefaultTypeInternal;
extern ErrorDefaultTypeInternal _Error_default_instance_;
class ErrorTest;
class ErrorTestDefaultTypeInternal;
extern ErrorTestDefaultTypeInternal _ErrorTest_default_instance_;
class Event;
class EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class Hashrate;
class HashrateDefaultTypeInternal;
extern HashrateDefaultTypeInternal _Hashrate_default_instance_;
class Job;
class JobDefaultTypeInternal;
extern JobDefaultTypeInternal _Job_default_instance_;
class MiningResult;
class MiningResultDefaultTypeInternal;
extern MiningResultDefaultTypeInternal _MiningResult_default_instance_;
class ResultReport;
class ResultReportDefaultTypeInternal;
extern ResultReportDefaultTypeInternal _ResultReport_default_instance_;
class Statistics;
class StatisticsDefaultTypeInternal;
extern StatisticsDefaultTypeInternal _Statistics_default_instance_;
class StatusReply;
class StatusReplyDefaultTypeInternal;
extern StatusReplyDefaultTypeInternal _StatusReply_default_instance_;
class StatusRequest;
class StatusRequestDefaultTypeInternal;
extern StatusRequestDefaultTypeInternal _StatusRequest_default_instance_;
class SystemStatus;
class SystemStatusDefaultTypeInternal;
extern SystemStatusDefaultTypeInternal _SystemStatus_default_instance_;
class SystemStatusReply;
class SystemStatusReplyDefaultTypeInternal;
extern SystemStatusReplyDefaultTypeInternal _SystemStatusReply_default_instance_;
class SystemStatusRequest;
class SystemStatusRequestDefaultTypeInternal;
extern SystemStatusRequestDefaultTypeInternal _SystemStatusRequest_default_instance_;
class TestMessage;
class TestMessageDefaultTypeInternal;
extern TestMessageDefaultTypeInternal _TestMessage_default_instance_;
}  // namespace cauchy
namespace google {
namespace protobuf {
class Timestamp;
class TimestampDefaultTypeInternal;
extern TimestampDefaultTypeInternal _Timestamp_default_instance_;
}  // namespace protobuf
}  // namespace google

namespace cauchy {

namespace protobuf_messages_2eproto {
// Internal implementation detail -- do not call these.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[];
  static const ::google::protobuf::uint32 offsets[];
  static void InitDefaultsImpl();
  static void Shutdown();
};
void AddDescriptors();
void InitDefaults();
}  // namespace protobuf_messages_2eproto

enum MiningResult_Result {
  MiningResult_Result_REJECTED = 0,
  MiningResult_Result_ACCEPTED = 1,
  MiningResult_Result_UNAUTHENTICATED = 3,
  MiningResult_Result_MiningResult_Result_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  MiningResult_Result_MiningResult_Result_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool MiningResult_Result_IsValid(int value);
const MiningResult_Result MiningResult_Result_Result_MIN = MiningResult_Result_REJECTED;
const MiningResult_Result MiningResult_Result_Result_MAX = MiningResult_Result_UNAUTHENTICATED;
const int MiningResult_Result_Result_ARRAYSIZE = MiningResult_Result_Result_MAX + 1;

const ::google::protobuf::EnumDescriptor* MiningResult_Result_descriptor();
inline const ::std::string& MiningResult_Result_Name(MiningResult_Result value) {
  return ::google::protobuf::internal::NameOfEnum(
    MiningResult_Result_descriptor(), value);
}
inline bool MiningResult_Result_Parse(
    const ::std::string& name, MiningResult_Result* value) {
  return ::google::protobuf::internal::ParseNamedEnum<MiningResult_Result>(
    MiningResult_Result_descriptor(), name, value);
}
enum StatusReply_Miner {
  StatusReply_Miner_XMR_CPU = 0,
  StatusReply_Miner_XMR_CUDA = 1,
  StatusReply_Miner_XMR_AMD = 2,
  StatusReply_Miner_ETH = 3,
  StatusReply_Miner_StatusReply_Miner_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  StatusReply_Miner_StatusReply_Miner_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool StatusReply_Miner_IsValid(int value);
const StatusReply_Miner StatusReply_Miner_Miner_MIN = StatusReply_Miner_XMR_CPU;
const StatusReply_Miner StatusReply_Miner_Miner_MAX = StatusReply_Miner_ETH;
const int StatusReply_Miner_Miner_ARRAYSIZE = StatusReply_Miner_Miner_MAX + 1;

const ::google::protobuf::EnumDescriptor* StatusReply_Miner_descriptor();
inline const ::std::string& StatusReply_Miner_Name(StatusReply_Miner value) {
  return ::google::protobuf::internal::NameOfEnum(
    StatusReply_Miner_descriptor(), value);
}
inline bool StatusReply_Miner_Parse(
    const ::std::string& name, StatusReply_Miner* value) {
  return ::google::protobuf::internal::ParseNamedEnum<StatusReply_Miner>(
    StatusReply_Miner_descriptor(), name, value);
}
enum SystemStatus_Miner {
  SystemStatus_Miner_XMR_CPU = 0,
  SystemStatus_Miner_XMR_CUDA = 1,
  SystemStatus_Miner_XMR_AMD = 2,
  SystemStatus_Miner_ETH_CPU = 3,
  SystemStatus_Miner_ETH_CUDA = 4,
  SystemStatus_Miner_SystemStatus_Miner_INT_MIN_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32min,
  SystemStatus_Miner_SystemStatus_Miner_INT_MAX_SENTINEL_DO_NOT_USE_ = ::google::protobuf::kint32max
};
bool SystemStatus_Miner_IsValid(int value);
const SystemStatus_Miner SystemStatus_Miner_Miner_MIN = SystemStatus_Miner_XMR_CPU;
const SystemStatus_Miner SystemStatus_Miner_Miner_MAX = SystemStatus_Miner_ETH_CUDA;
const int SystemStatus_Miner_Miner_ARRAYSIZE = SystemStatus_Miner_Miner_MAX + 1;

const ::google::protobuf::EnumDescriptor* SystemStatus_Miner_descriptor();
inline const ::std::string& SystemStatus_Miner_Name(SystemStatus_Miner value) {
  return ::google::protobuf::internal::NameOfEnum(
    SystemStatus_Miner_descriptor(), value);
}
inline bool SystemStatus_Miner_Parse(
    const ::std::string& name, SystemStatus_Miner* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SystemStatus_Miner>(
    SystemStatus_Miner_descriptor(), name, value);
}
// ===================================================================

class TestMessage : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cauchy.TestMessage) */ {
 public:
  TestMessage();
  virtual ~TestMessage();

  TestMessage(const TestMessage& from);

  inline TestMessage& operator=(const TestMessage& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TestMessage& default_instance();

  static inline const TestMessage* internal_default_instance() {
    return reinterpret_cast<const TestMessage*>(
               &_TestMessage_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(TestMessage* other);

  // implements Message ----------------------------------------------

  inline TestMessage* New() const PROTOBUF_FINAL { return New(NULL); }

  TestMessage* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const TestMessage& from);
  void MergeFrom(const TestMessage& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(TestMessage* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string debug = 3;
  void clear_debug();
  static const int kDebugFieldNumber = 3;
  const ::std::string& debug() const;
  void set_debug(const ::std::string& value);
  #if LANG_CXX11
  void set_debug(::std::string&& value);
  #endif
  void set_debug(const char* value);
  void set_debug(const char* value, size_t size);
  ::std::string* mutable_debug();
  ::std::string* release_debug();
  void set_allocated_debug(::std::string* debug);

  // .cauchy.ErrorTest error = 1;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 1;
  const ::cauchy::ErrorTest& error() const;
  ::cauchy::ErrorTest* mutable_error();
  ::cauchy::ErrorTest* release_error();
  void set_allocated_error(::cauchy::ErrorTest* error);

  // @@protoc_insertion_point(class_scope:cauchy.TestMessage)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr debug_;
  ::cauchy::ErrorTest* error_;
  mutable int _cached_size_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class ErrorTest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cauchy.ErrorTest) */ {
 public:
  ErrorTest();
  virtual ~ErrorTest();

  ErrorTest(const ErrorTest& from);

  inline ErrorTest& operator=(const ErrorTest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const ErrorTest& default_instance();

  static inline const ErrorTest* internal_default_instance() {
    return reinterpret_cast<const ErrorTest*>(
               &_ErrorTest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(ErrorTest* other);

  // implements Message ----------------------------------------------

  inline ErrorTest* New() const PROTOBUF_FINAL { return New(NULL); }

  ErrorTest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const ErrorTest& from);
  void MergeFrom(const ErrorTest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(ErrorTest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 1;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:cauchy.ErrorTest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  mutable int _cached_size_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Event : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cauchy.Event) */ {
 public:
  Event();
  virtual ~Event();

  Event(const Event& from);

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Event& default_instance();

  enum TypeCase {
    kConnection = 1,
    kReply = 2,
    kError = 3,
    kEnd = 4,
    kEmpty = 5,
    kResult = 6,
    kJob = 7,
    TYPE_NOT_SET = 0,
  };

  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(Event* other);

  // implements Message ----------------------------------------------

  inline Event* New() const PROTOBUF_FINAL { return New(NULL); }

  Event* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Event* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string debug = 10;
  void clear_debug();
  static const int kDebugFieldNumber = 10;
  const ::std::string& debug() const;
  void set_debug(const ::std::string& value);
  #if LANG_CXX11
  void set_debug(::std::string&& value);
  #endif
  void set_debug(const char* value);
  void set_debug(const char* value, size_t size);
  ::std::string* mutable_debug();
  ::std::string* release_debug();
  void set_allocated_debug(::std::string* debug);

  // .google.protobuf.Timestamp timestamp = 8;
  bool has_timestamp() const;
  void clear_timestamp();
  static const int kTimestampFieldNumber = 8;
  const ::google::protobuf::Timestamp& timestamp() const;
  ::google::protobuf::Timestamp* mutable_timestamp();
  ::google::protobuf::Timestamp* release_timestamp();
  void set_allocated_timestamp(::google::protobuf::Timestamp* timestamp);

  // .cauchy.SystemStatus status = 9;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 9;
  const ::cauchy::SystemStatus& status() const;
  ::cauchy::SystemStatus* mutable_status();
  ::cauchy::SystemStatus* release_status();
  void set_allocated_status(::cauchy::SystemStatus* status);

  // .cauchy.Connection connection = 1;
  bool has_connection() const;
  void clear_connection();
  static const int kConnectionFieldNumber = 1;
  const ::cauchy::Connection& connection() const;
  ::cauchy::Connection* mutable_connection();
  ::cauchy::Connection* release_connection();
  void set_allocated_connection(::cauchy::Connection* connection);

  // .cauchy.StatusReply reply = 2;
  bool has_reply() const;
  void clear_reply();
  static const int kReplyFieldNumber = 2;
  const ::cauchy::StatusReply& reply() const;
  ::cauchy::StatusReply* mutable_reply();
  ::cauchy::StatusReply* release_reply();
  void set_allocated_reply(::cauchy::StatusReply* reply);

  // .cauchy.Error error = 3;
  bool has_error() const;
  void clear_error();
  static const int kErrorFieldNumber = 3;
  const ::cauchy::Error& error() const;
  ::cauchy::Error* mutable_error();
  ::cauchy::Error* release_error();
  void set_allocated_error(::cauchy::Error* error);

  // .cauchy.End end = 4;
  bool has_end() const;
  void clear_end();
  static const int kEndFieldNumber = 4;
  const ::cauchy::End& end() const;
  ::cauchy::End* mutable_end();
  ::cauchy::End* release_end();
  void set_allocated_end(::cauchy::End* end);

  // .cauchy.Empty empty = 5;
  bool has_empty() const;
  void clear_empty();
  static const int kEmptyFieldNumber = 5;
  const ::cauchy::Empty& empty() const;
  ::cauchy::Empty* mutable_empty();
  ::cauchy::Empty* release_empty();
  void set_allocated_empty(::cauchy::Empty* empty);

  // .cauchy.MiningResult result = 6;
  bool has_result() const;
  void clear_result();
  static const int kResultFieldNumber = 6;
  const ::cauchy::MiningResult& result() const;
  ::cauchy::MiningResult* mutable_result();
  ::cauchy::MiningResult* release_result();
  void set_allocated_result(::cauchy::MiningResult* result);

  // .cauchy.Job job = 7;
  bool has_job() const;
  void clear_job();
  static const int kJobFieldNumber = 7;
  const ::cauchy::Job& job() const;
  ::cauchy::Job* mutable_job();
  ::cauchy::Job* release_job();
  void set_allocated_job(::cauchy::Job* job);

  TypeCase type_case() const;
  // @@protoc_insertion_point(class_scope:cauchy.Event)
 private:
  void set_has_connection();
  void set_has_reply();
  void set_has_error();
  void set_has_end();
  void set_has_empty();
  void set_has_result();
  void set_has_job();

  inline bool has_type() const;
  void clear_type();
  inline void clear_has_type();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr debug_;
  ::google::protobuf::Timestamp* timestamp_;
  ::cauchy::SystemStatus* status_;
  union TypeUnion {
    TypeUnion() {}
    ::cauchy::Connection* connection_;
    ::cauchy::StatusReply* reply_;
    ::cauchy::Error* error_;
    ::cauchy::End* end_;
    ::cauchy::Empty* empty_;
    ::cauchy::MiningResult* result_;
    ::cauchy::Job* job_;
  } type_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Connection : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cauchy.Connection) */ {
 public:
  Connection();
  virtual ~Connection();

  Connection(const Connection& from);

  inline Connection& operator=(const Connection& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Connection& default_instance();

  static inline const Connection* internal_default_instance() {
    return reinterpret_cast<const Connection*>(
               &_Connection_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(Connection* other);

  // implements Message ----------------------------------------------

  inline Connection* New() const PROTOBUF_FINAL { return New(NULL); }

  Connection* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Connection& from);
  void MergeFrom(const Connection& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Connection* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string pool = 1;
  void clear_pool();
  static const int kPoolFieldNumber = 1;
  const ::std::string& pool() const;
  void set_pool(const ::std::string& value);
  #if LANG_CXX11
  void set_pool(::std::string&& value);
  #endif
  void set_pool(const char* value);
  void set_pool(const char* value, size_t size);
  ::std::string* mutable_pool();
  ::std::string* release_pool();
  void set_allocated_pool(::std::string* pool);

  // @@protoc_insertion_point(class_scope:cauchy.Connection)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr pool_;
  mutable int _cached_size_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class MiningResult : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cauchy.MiningResult) */ {
 public:
  MiningResult();
  virtual ~MiningResult();

  MiningResult(const MiningResult& from);

  inline MiningResult& operator=(const MiningResult& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const MiningResult& default_instance();

  static inline const MiningResult* internal_default_instance() {
    return reinterpret_cast<const MiningResult*>(
               &_MiningResult_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(MiningResult* other);

  // implements Message ----------------------------------------------

  inline MiningResult* New() const PROTOBUF_FINAL { return New(NULL); }

  MiningResult* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const MiningResult& from);
  void MergeFrom(const MiningResult& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(MiningResult* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef MiningResult_Result Result;
  static const Result REJECTED =
    MiningResult_Result_REJECTED;
  static const Result ACCEPTED =
    MiningResult_Result_ACCEPTED;
  static const Result UNAUTHENTICATED =
    MiningResult_Result_UNAUTHENTICATED;
  static inline bool Result_IsValid(int value) {
    return MiningResult_Result_IsValid(value);
  }
  static const Result Result_MIN =
    MiningResult_Result_Result_MIN;
  static const Result Result_MAX =
    MiningResult_Result_Result_MAX;
  static const int Result_ARRAYSIZE =
    MiningResult_Result_Result_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Result_descriptor() {
    return MiningResult_Result_descriptor();
  }
  static inline const ::std::string& Result_Name(Result value) {
    return MiningResult_Result_Name(value);
  }
  static inline bool Result_Parse(const ::std::string& name,
      Result* value) {
    return MiningResult_Result_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .cauchy.MiningResult.Result result = 1;
  void clear_result();
  static const int kResultFieldNumber = 1;
  ::cauchy::MiningResult_Result result() const;
  void set_result(::cauchy::MiningResult_Result value);

  // @@protoc_insertion_point(class_scope:cauchy.MiningResult)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  int result_;
  mutable int _cached_size_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Job : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cauchy.Job) */ {
 public:
  Job();
  virtual ~Job();

  Job(const Job& from);

  inline Job& operator=(const Job& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Job& default_instance();

  static inline const Job* internal_default_instance() {
    return reinterpret_cast<const Job*>(
               &_Job_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(Job* other);

  // implements Message ----------------------------------------------

  inline Job* New() const PROTOBUF_FINAL { return New(NULL); }

  Job* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Job& from);
  void MergeFrom(const Job& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Job* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // uint64 diff = 1;
  void clear_diff();
  static const int kDiffFieldNumber = 1;
  ::google::protobuf::uint64 diff() const;
  void set_diff(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:cauchy.Job)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::uint64 diff_;
  mutable int _cached_size_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DifficultyChange : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cauchy.DifficultyChange) */ {
 public:
  DifficultyChange();
  virtual ~DifficultyChange();

  DifficultyChange(const DifficultyChange& from);

  inline DifficultyChange& operator=(const DifficultyChange& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DifficultyChange& default_instance();

  static inline const DifficultyChange* internal_default_instance() {
    return reinterpret_cast<const DifficultyChange*>(
               &_DifficultyChange_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(DifficultyChange* other);

  // implements Message ----------------------------------------------

  inline DifficultyChange* New() const PROTOBUF_FINAL { return New(NULL); }

  DifficultyChange* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const DifficultyChange& from);
  void MergeFrom(const DifficultyChange& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(DifficultyChange* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // @@protoc_insertion_point(class_scope:cauchy.DifficultyChange)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  mutable int _cached_size_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Error : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cauchy.Error) */ {
 public:
  Error();
  virtual ~Error();

  Error(const Error& from);

  inline Error& operator=(const Error& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Error& default_instance();

  static inline const Error* internal_default_instance() {
    return reinterpret_cast<const Error*>(
               &_Error_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(Error* other);

  // implements Message ----------------------------------------------

  inline Error* New() const PROTOBUF_FINAL { return New(NULL); }

  Error* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Error& from);
  void MergeFrom(const Error& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Error* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 1;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:cauchy.Error)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  mutable int _cached_size_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class End : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cauchy.End) */ {
 public:
  End();
  virtual ~End();

  End(const End& from);

  inline End& operator=(const End& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const End& default_instance();

  static inline const End* internal_default_instance() {
    return reinterpret_cast<const End*>(
               &_End_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(End* other);

  // implements Message ----------------------------------------------

  inline End* New() const PROTOBUF_FINAL { return New(NULL); }

  End* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const End& from);
  void MergeFrom(const End& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(End* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  const ::std::string& status() const;
  void set_status(const ::std::string& value);
  #if LANG_CXX11
  void set_status(::std::string&& value);
  #endif
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  ::std::string* mutable_status();
  ::std::string* release_status();
  void set_allocated_status(::std::string* status);

  // @@protoc_insertion_point(class_scope:cauchy.End)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr status_;
  mutable int _cached_size_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Empty : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cauchy.Empty) */ {
 public:
  Empty();
  virtual ~Empty();

  Empty(const Empty& from);

  inline Empty& operator=(const Empty& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Empty& default_instance();

  static inline const Empty* internal_default_instance() {
    return reinterpret_cast<const Empty*>(
               &_Empty_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(Empty* other);

  // implements Message ----------------------------------------------

  inline Empty* New() const PROTOBUF_FINAL { return New(NULL); }

  Empty* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Empty& from);
  void MergeFrom(const Empty& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Empty* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string status = 1;
  void clear_status();
  static const int kStatusFieldNumber = 1;
  const ::std::string& status() const;
  void set_status(const ::std::string& value);
  #if LANG_CXX11
  void set_status(::std::string&& value);
  #endif
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  ::std::string* mutable_status();
  ::std::string* release_status();
  void set_allocated_status(::std::string* status);

  // @@protoc_insertion_point(class_scope:cauchy.Empty)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr status_;
  mutable int _cached_size_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StatusRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cauchy.StatusRequest) */ {
 public:
  StatusRequest();
  virtual ~StatusRequest();

  StatusRequest(const StatusRequest& from);

  inline StatusRequest& operator=(const StatusRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusRequest& default_instance();

  static inline const StatusRequest* internal_default_instance() {
    return reinterpret_cast<const StatusRequest*>(
               &_StatusRequest_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    10;

  void Swap(StatusRequest* other);

  // implements Message ----------------------------------------------

  inline StatusRequest* New() const PROTOBUF_FINAL { return New(NULL); }

  StatusRequest* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StatusRequest& from);
  void MergeFrom(const StatusRequest& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StatusRequest* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // string message = 1;
  void clear_message();
  static const int kMessageFieldNumber = 1;
  const ::std::string& message() const;
  void set_message(const ::std::string& value);
  #if LANG_CXX11
  void set_message(::std::string&& value);
  #endif
  void set_message(const char* value);
  void set_message(const char* value, size_t size);
  ::std::string* mutable_message();
  ::std::string* release_message();
  void set_allocated_message(::std::string* message);

  // @@protoc_insertion_point(class_scope:cauchy.StatusRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr message_;
  mutable int _cached_size_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class StatusReply : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cauchy.StatusReply) */ {
 public:
  StatusReply();
  virtual ~StatusReply();

  StatusReply(const StatusReply& from);

  inline StatusReply& operator=(const StatusReply& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const StatusReply& default_instance();

  static inline const StatusReply* internal_default_instance() {
    return reinterpret_cast<const StatusReply*>(
               &_StatusReply_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    11;

  void Swap(StatusReply* other);

  // implements Message ----------------------------------------------

  inline StatusReply* New() const PROTOBUF_FINAL { return New(NULL); }

  StatusReply* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const StatusReply& from);
  void MergeFrom(const StatusReply& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(StatusReply* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef StatusReply_Miner Miner;
  static const Miner XMR_CPU =
    StatusReply_Miner_XMR_CPU;
  static const Miner XMR_CUDA =
    StatusReply_Miner_XMR_CUDA;
  static const Miner XMR_AMD =
    StatusReply_Miner_XMR_AMD;
  static const Miner ETH =
    StatusReply_Miner_ETH;
  static inline bool Miner_IsValid(int value) {
    return StatusReply_Miner_IsValid(value);
  }
  static const Miner Miner_MIN =
    StatusReply_Miner_Miner_MIN;
  static const Miner Miner_MAX =
    StatusReply_Miner_Miner_MAX;
  static const int Miner_ARRAYSIZE =
    StatusReply_Miner_Miner_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Miner_descriptor() {
    return StatusReply_Miner_descriptor();
  }
  static inline const ::std::string& Miner_Name(Miner value) {
    return StatusReply_Miner_Name(value);
  }
  static inline bool Miner_Parse(const ::std::string& name,
      Miner* value) {
    return StatusReply_Miner_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // .cauchy.Statistics stats = 2;
  bool has_stats() const;
  void clear_stats();
  static const int kStatsFieldNumber = 2;
  const ::cauchy::Statistics& stats() const;
  ::cauchy::Statistics* mutable_stats();
  ::cauchy::Statistics* release_stats();
  void set_allocated_stats(::cauchy::Statistics* stats);

  // .cauchy.StatusReply.Miner miner = 1;
  void clear_miner();
  static const int kMinerFieldNumber = 1;
  ::cauchy::StatusReply_Miner miner() const;
  void set_miner(::cauchy::StatusReply_Miner value);

  // @@protoc_insertion_point(class_scope:cauchy.StatusReply)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::cauchy::Statistics* stats_;
  int miner_;
  mutable int _cached_size_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class SystemStatus : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:cauchy.SystemStatus) */ {
 public:
  SystemStatus();
  virtual ~SystemStatus();

  SystemStatus(const SystemStatus& from);

  inline SystemStatus& operator=(const SystemStatus& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SystemStatus& default_instance();

  static inline const SystemStatus* internal_default_instance() {
    return reinterpret_cast<const SystemStatus*>(
               &_SystemStatus_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    12;

  void Swap(SystemStatus* other);

  // implements Message ----------------------------------------------

  inline SystemStatus* New() const PROTOBUF_FINAL { return New(NULL); }

  SystemStatus* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const SystemStatus& from);
  void MergeFrom(const SystemStatus& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(SystemStatus* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef SystemStatus_Miner Miner;
  static const Miner XMR_CPU =
    SystemStatus_Miner_XMR_CPU;
  static const Miner XMR_CUDA =
    SystemStatus_Miner_XMR_CUDA;
  static const Miner XMR_AMD =
    SystemStatus_Miner_XMR_AMD;
  static const Miner ETH_CPU =
    SystemStatus_Miner_ETH_CPU;
  static const Miner ETH_CUDA =
    SystemStatus_Miner_ETH_CUDA;
  static inline bool Miner_IsValid(int value) {
    return SystemStatus_Miner_IsValid(value);
  }
  static const Miner Miner_MIN =
    SystemStatus_Miner_Miner_MIN;
  static const Miner Miner_MAX =
    SystemStatus_Miner_Miner_MAX;
  static const int Miner_ARRAYSIZE =
    SystemStatus_Miner_Miner_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Miner_descriptor() {
    return SystemStatus_Miner_descriptor();
  }
  static inline const ::std::string& Miner_Name(Miner value) {
    return SystemStatus_Miner_Name(value);
  }
  static inline bool Miner_Parse(const ::std::string& name,
      Miner* value) {
    return SystemStatus_Miner_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // bool running = 1;
  void clear_running();
  static const int kRunningFieldNumber = 1;
  bool running() const;
  void set_running(bool value);

  // .cauchy.SystemStatus.Miner miner = 2;
  void clear_miner();
  static const int kMinerFieldNumber = 2;
  ::cauchy::SystemStatus_Miner miner() const;
  void set_miner(::cauchy::SystemStatus_Miner value);

  // @@protoc_insertion_point(class_scope:cauchy.SystemStatus)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  bool running_;
  int miner_;
  mutable int _cached_size_;
  friend struct protobuf_messages_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// TestMessage

// .cauchy.ErrorTest error = 1;
inline bool TestMessage::has_error() const {
  return this != internal_default_instance() && error_ != NULL;
}
inline void TestMessage::clear_error() {
  if (GetArenaNoVirtual() == NULL && error_ != NULL) delete error_;
  error_ = NULL;
}
inline const ::cauchy::ErrorTest& TestMessage::error() const {
  // @@protoc_insertion_point(field_get:cauchy.TestMessage.error)
  return error_ != NULL ? *error_
                         : *::cauchy::ErrorTest::internal_default_instance();
}
inline ::cauchy::ErrorTest* TestMessage::mutable_error() {
  
  if (error_ == NULL) {
    error_ = new ::cauchy::ErrorTest;
  }
  // @@protoc_insertion_point(field_mutable:cauchy.TestMessage.error)
  return error_;
}
inline ::cauchy::ErrorTest* TestMessage::release_error() {
  // @@protoc_insertion_point(field_release:cauchy.TestMessage.error)
  
  ::cauchy::ErrorTest* temp = error_;
  error_ = NULL;
  return temp;
}
inline void TestMessage::set_allocated_error(::cauchy::ErrorTest* error) {
  delete error_;
  error_ = error;
  if (error) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:cauchy.TestMessage.error)
}

// string debug = 3;
inline void TestMessage::clear_debug() {
  debug_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TestMessage::debug() const {
  // @@protoc_insertion_point(field_get:cauchy.TestMessage.debug)
  return debug_.GetNoArena();
}
inline void TestMessage::set_debug(const ::std::string& value) {
  
  debug_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cauchy.TestMessage.debug)
}
#if LANG_CXX11
inline void TestMessage::set_debug(::std::string&& value) {
  
  debug_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cauchy.TestMessage.debug)
}
#endif
inline void TestMessage::set_debug(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  debug_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cauchy.TestMessage.debug)
}
inline void TestMessage::set_debug(const char* value, size_t size) {
  
  debug_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cauchy.TestMessage.debug)
}
inline ::std::string* TestMessage::mutable_debug() {
  
  // @@protoc_insertion_point(field_mutable:cauchy.TestMessage.debug)
  return debug_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TestMessage::release_debug() {
  // @@protoc_insertion_point(field_release:cauchy.TestMessage.debug)
  
  return debug_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TestMessage::set_allocated_debug(::std::string* debug) {
  if (debug != NULL) {
    
  } else {
    
  }
  debug_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), debug);
  // @@protoc_insertion_point(field_set_allocated:cauchy.TestMessage.debug)
}

// -------------------------------------------------------------------

// ErrorTest

// string message = 1;
inline void ErrorTest::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& ErrorTest::message() const {
  // @@protoc_insertion_point(field_get:cauchy.ErrorTest.message)
  return message_.GetNoArena();
}
inline void ErrorTest::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cauchy.ErrorTest.message)
}
#if LANG_CXX11
inline void ErrorTest::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cauchy.ErrorTest.message)
}
#endif
inline void ErrorTest::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cauchy.ErrorTest.message)
}
inline void ErrorTest::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cauchy.ErrorTest.message)
}
inline ::std::string* ErrorTest::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:cauchy.ErrorTest.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ErrorTest::release_message() {
  // @@protoc_insertion_point(field_release:cauchy.ErrorTest.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ErrorTest::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:cauchy.ErrorTest.message)
}

// -------------------------------------------------------------------

// Event

// .cauchy.Connection connection = 1;
inline bool Event::has_connection() const {
  return type_case() == kConnection;
}
inline void Event::set_has_connection() {
  _oneof_case_[0] = kConnection;
}
inline void Event::clear_connection() {
  if (has_connection()) {
    delete type_.connection_;
    clear_has_type();
  }
}
inline  const ::cauchy::Connection& Event::connection() const {
  // @@protoc_insertion_point(field_get:cauchy.Event.connection)
  return has_connection()
      ? *type_.connection_
      : ::cauchy::Connection::default_instance();
}
inline ::cauchy::Connection* Event::mutable_connection() {
  if (!has_connection()) {
    clear_type();
    set_has_connection();
    type_.connection_ = new ::cauchy::Connection;
  }
  // @@protoc_insertion_point(field_mutable:cauchy.Event.connection)
  return type_.connection_;
}
inline ::cauchy::Connection* Event::release_connection() {
  // @@protoc_insertion_point(field_release:cauchy.Event.connection)
  if (has_connection()) {
    clear_has_type();
    ::cauchy::Connection* temp = type_.connection_;
    type_.connection_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Event::set_allocated_connection(::cauchy::Connection* connection) {
  clear_type();
  if (connection) {
    set_has_connection();
    type_.connection_ = connection;
  }
  // @@protoc_insertion_point(field_set_allocated:cauchy.Event.connection)
}

// .cauchy.StatusReply reply = 2;
inline bool Event::has_reply() const {
  return type_case() == kReply;
}
inline void Event::set_has_reply() {
  _oneof_case_[0] = kReply;
}
inline void Event::clear_reply() {
  if (has_reply()) {
    delete type_.reply_;
    clear_has_type();
  }
}
inline  const ::cauchy::StatusReply& Event::reply() const {
  // @@protoc_insertion_point(field_get:cauchy.Event.reply)
  return has_reply()
      ? *type_.reply_
      : ::cauchy::StatusReply::default_instance();
}
inline ::cauchy::StatusReply* Event::mutable_reply() {
  if (!has_reply()) {
    clear_type();
    set_has_reply();
    type_.reply_ = new ::cauchy::StatusReply;
  }
  // @@protoc_insertion_point(field_mutable:cauchy.Event.reply)
  return type_.reply_;
}
inline ::cauchy::StatusReply* Event::release_reply() {
  // @@protoc_insertion_point(field_release:cauchy.Event.reply)
  if (has_reply()) {
    clear_has_type();
    ::cauchy::StatusReply* temp = type_.reply_;
    type_.reply_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Event::set_allocated_reply(::cauchy::StatusReply* reply) {
  clear_type();
  if (reply) {
    set_has_reply();
    type_.reply_ = reply;
  }
  // @@protoc_insertion_point(field_set_allocated:cauchy.Event.reply)
}

// .cauchy.Error error = 3;
inline bool Event::has_error() const {
  return type_case() == kError;
}
inline void Event::set_has_error() {
  _oneof_case_[0] = kError;
}
inline void Event::clear_error() {
  if (has_error()) {
    delete type_.error_;
    clear_has_type();
  }
}
inline  const ::cauchy::Error& Event::error() const {
  // @@protoc_insertion_point(field_get:cauchy.Event.error)
  return has_error()
      ? *type_.error_
      : ::cauchy::Error::default_instance();
}
inline ::cauchy::Error* Event::mutable_error() {
  if (!has_error()) {
    clear_type();
    set_has_error();
    type_.error_ = new ::cauchy::Error;
  }
  // @@protoc_insertion_point(field_mutable:cauchy.Event.error)
  return type_.error_;
}
inline ::cauchy::Error* Event::release_error() {
  // @@protoc_insertion_point(field_release:cauchy.Event.error)
  if (has_error()) {
    clear_has_type();
    ::cauchy::Error* temp = type_.error_;
    type_.error_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Event::set_allocated_error(::cauchy::Error* error) {
  clear_type();
  if (error) {
    set_has_error();
    type_.error_ = error;
  }
  // @@protoc_insertion_point(field_set_allocated:cauchy.Event.error)
}

// .cauchy.End end = 4;
inline bool Event::has_end() const {
  return type_case() == kEnd;
}
inline void Event::set_has_end() {
  _oneof_case_[0] = kEnd;
}
inline void Event::clear_end() {
  if (has_end()) {
    delete type_.end_;
    clear_has_type();
  }
}
inline  const ::cauchy::End& Event::end() const {
  // @@protoc_insertion_point(field_get:cauchy.Event.end)
  return has_end()
      ? *type_.end_
      : ::cauchy::End::default_instance();
}
inline ::cauchy::End* Event::mutable_end() {
  if (!has_end()) {
    clear_type();
    set_has_end();
    type_.end_ = new ::cauchy::End;
  }
  // @@protoc_insertion_point(field_mutable:cauchy.Event.end)
  return type_.end_;
}
inline ::cauchy::End* Event::release_end() {
  // @@protoc_insertion_point(field_release:cauchy.Event.end)
  if (has_end()) {
    clear_has_type();
    ::cauchy::End* temp = type_.end_;
    type_.end_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Event::set_allocated_end(::cauchy::End* end) {
  clear_type();
  if (end) {
    set_has_end();
    type_.end_ = end;
  }
  // @@protoc_insertion_point(field_set_allocated:cauchy.Event.end)
}

// .cauchy.Empty empty = 5;
inline bool Event::has_empty() const {
  return type_case() == kEmpty;
}
inline void Event::set_has_empty() {
  _oneof_case_[0] = kEmpty;
}
inline void Event::clear_empty() {
  if (has_empty()) {
    delete type_.empty_;
    clear_has_type();
  }
}
inline  const ::cauchy::Empty& Event::empty() const {
  // @@protoc_insertion_point(field_get:cauchy.Event.empty)
  return has_empty()
      ? *type_.empty_
      : ::cauchy::Empty::default_instance();
}
inline ::cauchy::Empty* Event::mutable_empty() {
  if (!has_empty()) {
    clear_type();
    set_has_empty();
    type_.empty_ = new ::cauchy::Empty;
  }
  // @@protoc_insertion_point(field_mutable:cauchy.Event.empty)
  return type_.empty_;
}
inline ::cauchy::Empty* Event::release_empty() {
  // @@protoc_insertion_point(field_release:cauchy.Event.empty)
  if (has_empty()) {
    clear_has_type();
    ::cauchy::Empty* temp = type_.empty_;
    type_.empty_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Event::set_allocated_empty(::cauchy::Empty* empty) {
  clear_type();
  if (empty) {
    set_has_empty();
    type_.empty_ = empty;
  }
  // @@protoc_insertion_point(field_set_allocated:cauchy.Event.empty)
}

// .cauchy.MiningResult result = 6;
inline bool Event::has_result() const {
  return type_case() == kResult;
}
inline void Event::set_has_result() {
  _oneof_case_[0] = kResult;
}
inline void Event::clear_result() {
  if (has_result()) {
    delete type_.result_;
    clear_has_type();
  }
}
inline  const ::cauchy::MiningResult& Event::result() const {
  // @@protoc_insertion_point(field_get:cauchy.Event.result)
  return has_result()
      ? *type_.result_
      : ::cauchy::MiningResult::default_instance();
}
inline ::cauchy::MiningResult* Event::mutable_result() {
  if (!has_result()) {
    clear_type();
    set_has_result();
    type_.result_ = new ::cauchy::MiningResult;
  }
  // @@protoc_insertion_point(field_mutable:cauchy.Event.result)
  return type_.result_;
}
inline ::cauchy::MiningResult* Event::release_result() {
  // @@protoc_insertion_point(field_release:cauchy.Event.result)
  if (has_result()) {
    clear_has_type();
    ::cauchy::MiningResult* temp = type_.result_;
    type_.result_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Event::set_allocated_result(::cauchy::MiningResult* result) {
  clear_type();
  if (result) {
    set_has_result();
    type_.result_ = result;
  }
  // @@protoc_insertion_point(field_set_allocated:cauchy.Event.result)
}

// .cauchy.Job job = 7;
inline bool Event::has_job() const {
  return type_case() == kJob;
}
inline void Event::set_has_job() {
  _oneof_case_[0] = kJob;
}
inline void Event::clear_job() {
  if (has_job()) {
    delete type_.job_;
    clear_has_type();
  }
}
inline  const ::cauchy::Job& Event::job() const {
  // @@protoc_insertion_point(field_get:cauchy.Event.job)
  return has_job()
      ? *type_.job_
      : ::cauchy::Job::default_instance();
}
inline ::cauchy::Job* Event::mutable_job() {
  if (!has_job()) {
    clear_type();
    set_has_job();
    type_.job_ = new ::cauchy::Job;
  }
  // @@protoc_insertion_point(field_mutable:cauchy.Event.job)
  return type_.job_;
}
inline ::cauchy::Job* Event::release_job() {
  // @@protoc_insertion_point(field_release:cauchy.Event.job)
  if (has_job()) {
    clear_has_type();
    ::cauchy::Job* temp = type_.job_;
    type_.job_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void Event::set_allocated_job(::cauchy::Job* job) {
  clear_type();
  if (job) {
    set_has_job();
    type_.job_ = job;
  }
  // @@protoc_insertion_point(field_set_allocated:cauchy.Event.job)
}

// .google.protobuf.Timestamp timestamp = 8;
inline bool Event::has_timestamp() const {
  return this != internal_default_instance() && timestamp_ != NULL;
}
inline void Event::clear_timestamp() {
  if (GetArenaNoVirtual() == NULL && timestamp_ != NULL) delete timestamp_;
  timestamp_ = NULL;
}
inline const ::google::protobuf::Timestamp& Event::timestamp() const {
  // @@protoc_insertion_point(field_get:cauchy.Event.timestamp)
  return timestamp_ != NULL ? *timestamp_
                         : *::google::protobuf::Timestamp::internal_default_instance();
}
inline ::google::protobuf::Timestamp* Event::mutable_timestamp() {
  
  if (timestamp_ == NULL) {
    timestamp_ = new ::google::protobuf::Timestamp;
  }
  // @@protoc_insertion_point(field_mutable:cauchy.Event.timestamp)
  return timestamp_;
}
inline ::google::protobuf::Timestamp* Event::release_timestamp() {
  // @@protoc_insertion_point(field_release:cauchy.Event.timestamp)
  
  ::google::protobuf::Timestamp* temp = timestamp_;
  timestamp_ = NULL;
  return temp;
}
inline void Event::set_allocated_timestamp(::google::protobuf::Timestamp* timestamp) {
  delete timestamp_;
  if (timestamp != NULL && timestamp->GetArena() != NULL) {
    ::google::protobuf::Timestamp* new_timestamp = new ::google::protobuf::Timestamp;
    new_timestamp->CopyFrom(*timestamp);
    timestamp = new_timestamp;
  }
  timestamp_ = timestamp;
  if (timestamp) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:cauchy.Event.timestamp)
}

// .cauchy.SystemStatus status = 9;
inline bool Event::has_status() const {
  return this != internal_default_instance() && status_ != NULL;
}
inline void Event::clear_status() {
  if (GetArenaNoVirtual() == NULL && status_ != NULL) delete status_;
  status_ = NULL;
}
inline const ::cauchy::SystemStatus& Event::status() const {
  // @@protoc_insertion_point(field_get:cauchy.Event.status)
  return status_ != NULL ? *status_
                         : *::cauchy::SystemStatus::internal_default_instance();
}
inline ::cauchy::SystemStatus* Event::mutable_status() {
  
  if (status_ == NULL) {
    status_ = new ::cauchy::SystemStatus;
  }
  // @@protoc_insertion_point(field_mutable:cauchy.Event.status)
  return status_;
}
inline ::cauchy::SystemStatus* Event::release_status() {
  // @@protoc_insertion_point(field_release:cauchy.Event.status)
  
  ::cauchy::SystemStatus* temp = status_;
  status_ = NULL;
  return temp;
}
inline void Event::set_allocated_status(::cauchy::SystemStatus* status) {
  delete status_;
  status_ = status;
  if (status) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:cauchy.Event.status)
}

// string debug = 10;
inline void Event::clear_debug() {
  debug_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Event::debug() const {
  // @@protoc_insertion_point(field_get:cauchy.Event.debug)
  return debug_.GetNoArena();
}
inline void Event::set_debug(const ::std::string& value) {
  
  debug_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cauchy.Event.debug)
}
#if LANG_CXX11
inline void Event::set_debug(::std::string&& value) {
  
  debug_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cauchy.Event.debug)
}
#endif
inline void Event::set_debug(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  debug_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cauchy.Event.debug)
}
inline void Event::set_debug(const char* value, size_t size) {
  
  debug_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cauchy.Event.debug)
}
inline ::std::string* Event::mutable_debug() {
  
  // @@protoc_insertion_point(field_mutable:cauchy.Event.debug)
  return debug_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Event::release_debug() {
  // @@protoc_insertion_point(field_release:cauchy.Event.debug)
  
  return debug_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Event::set_allocated_debug(::std::string* debug) {
  if (debug != NULL) {
    
  } else {
    
  }
  debug_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), debug);
  // @@protoc_insertion_point(field_set_allocated:cauchy.Event.debug)
}

inline bool Event::has_type() const {
  return type_case() != TYPE_NOT_SET;
}
inline void Event::clear_has_type() {
  _oneof_case_[0] = TYPE_NOT_SET;
}
inline Event::TypeCase Event::type_case() const {
  return Event::TypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// Connection

// string pool = 1;
inline void Connection::clear_pool() {
  pool_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Connection::pool() const {
  // @@protoc_insertion_point(field_get:cauchy.Connection.pool)
  return pool_.GetNoArena();
}
inline void Connection::set_pool(const ::std::string& value) {
  
  pool_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cauchy.Connection.pool)
}
#if LANG_CXX11
inline void Connection::set_pool(::std::string&& value) {
  
  pool_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cauchy.Connection.pool)
}
#endif
inline void Connection::set_pool(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  pool_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cauchy.Connection.pool)
}
inline void Connection::set_pool(const char* value, size_t size) {
  
  pool_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cauchy.Connection.pool)
}
inline ::std::string* Connection::mutable_pool() {
  
  // @@protoc_insertion_point(field_mutable:cauchy.Connection.pool)
  return pool_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Connection::release_pool() {
  // @@protoc_insertion_point(field_release:cauchy.Connection.pool)
  
  return pool_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Connection::set_allocated_pool(::std::string* pool) {
  if (pool != NULL) {
    
  } else {
    
  }
  pool_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), pool);
  // @@protoc_insertion_point(field_set_allocated:cauchy.Connection.pool)
}

// -------------------------------------------------------------------

// MiningResult

// .cauchy.MiningResult.Result result = 1;
inline void MiningResult::clear_result() {
  result_ = 0;
}
inline ::cauchy::MiningResult_Result MiningResult::result() const {
  // @@protoc_insertion_point(field_get:cauchy.MiningResult.result)
  return static_cast< ::cauchy::MiningResult_Result >(result_);
}
inline void MiningResult::set_result(::cauchy::MiningResult_Result value) {
  
  result_ = value;
  // @@protoc_insertion_point(field_set:cauchy.MiningResult.result)
}

// -------------------------------------------------------------------

// Job

// uint64 diff = 1;
inline void Job::clear_diff() {
  diff_ = GOOGLE_ULONGLONG(0);
}
inline ::google::protobuf::uint64 Job::diff() const {
  // @@protoc_insertion_point(field_get:cauchy.Job.diff)
  return diff_;
}
inline void Job::set_diff(::google::protobuf::uint64 value) {
  
  diff_ = value;
  // @@protoc_insertion_point(field_set:cauchy.Job.diff)
}

// -------------------------------------------------------------------

// DifficultyChange

// -------------------------------------------------------------------

// Error

// string message = 1;
inline void Error::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Error::message() const {
  // @@protoc_insertion_point(field_get:cauchy.Error.message)
  return message_.GetNoArena();
}
inline void Error::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cauchy.Error.message)
}
#if LANG_CXX11
inline void Error::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cauchy.Error.message)
}
#endif
inline void Error::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cauchy.Error.message)
}
inline void Error::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cauchy.Error.message)
}
inline ::std::string* Error::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:cauchy.Error.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Error::release_message() {
  // @@protoc_insertion_point(field_release:cauchy.Error.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Error::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:cauchy.Error.message)
}

// -------------------------------------------------------------------

// End

// string status = 1;
inline void End::clear_status() {
  status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& End::status() const {
  // @@protoc_insertion_point(field_get:cauchy.End.status)
  return status_.GetNoArena();
}
inline void End::set_status(const ::std::string& value) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cauchy.End.status)
}
#if LANG_CXX11
inline void End::set_status(::std::string&& value) {
  
  status_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cauchy.End.status)
}
#endif
inline void End::set_status(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cauchy.End.status)
}
inline void End::set_status(const char* value, size_t size) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cauchy.End.status)
}
inline ::std::string* End::mutable_status() {
  
  // @@protoc_insertion_point(field_mutable:cauchy.End.status)
  return status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* End::release_status() {
  // @@protoc_insertion_point(field_release:cauchy.End.status)
  
  return status_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void End::set_allocated_status(::std::string* status) {
  if (status != NULL) {
    
  } else {
    
  }
  status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status);
  // @@protoc_insertion_point(field_set_allocated:cauchy.End.status)
}

// -------------------------------------------------------------------

// Empty

// string status = 1;
inline void Empty::clear_status() {
  status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Empty::status() const {
  // @@protoc_insertion_point(field_get:cauchy.Empty.status)
  return status_.GetNoArena();
}
inline void Empty::set_status(const ::std::string& value) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cauchy.Empty.status)
}
#if LANG_CXX11
inline void Empty::set_status(::std::string&& value) {
  
  status_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cauchy.Empty.status)
}
#endif
inline void Empty::set_status(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cauchy.Empty.status)
}
inline void Empty::set_status(const char* value, size_t size) {
  
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cauchy.Empty.status)
}
inline ::std::string* Empty::mutable_status() {
  
  // @@protoc_insertion_point(field_mutable:cauchy.Empty.status)
  return status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Empty::release_status() {
  // @@protoc_insertion_point(field_release:cauchy.Empty.status)
  
  return status_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Empty::set_allocated_status(::std::string* status) {
  if (status != NULL) {
    
  } else {
    
  }
  status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status);
  // @@protoc_insertion_point(field_set_allocated:cauchy.Empty.status)
}

// -------------------------------------------------------------------

// StatusRequest

// string message = 1;
inline void StatusRequest::clear_message() {
  message_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& StatusRequest::message() const {
  // @@protoc_insertion_point(field_get:cauchy.StatusRequest.message)
  return message_.GetNoArena();
}
inline void StatusRequest::set_message(const ::std::string& value) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:cauchy.StatusRequest.message)
}
#if LANG_CXX11
inline void StatusRequest::set_message(::std::string&& value) {
  
  message_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:cauchy.StatusRequest.message)
}
#endif
inline void StatusRequest::set_message(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:cauchy.StatusRequest.message)
}
inline void StatusRequest::set_message(const char* value, size_t size) {
  
  message_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:cauchy.StatusRequest.message)
}
inline ::std::string* StatusRequest::mutable_message() {
  
  // @@protoc_insertion_point(field_mutable:cauchy.StatusRequest.message)
  return message_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StatusRequest::release_message() {
  // @@protoc_insertion_point(field_release:cauchy.StatusRequest.message)
  
  return message_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StatusRequest::set_allocated_message(::std::string* message) {
  if (message != NULL) {
    
  } else {
    
  }
  message_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), message);
  // @@protoc_insertion_point(field_set_allocated:cauchy.StatusRequest.message)
}

// -------------------------------------------------------------------

// StatusReply

// .cauchy.StatusReply.Miner miner = 1;
inline void StatusReply::clear_miner() {
  miner_ = 0;
}
inline ::cauchy::StatusReply_Miner StatusReply::miner() const {
  // @@protoc_insertion_point(field_get:cauchy.StatusReply.miner)
  return static_cast< ::cauchy::StatusReply_Miner >(miner_);
}
inline void StatusReply::set_miner(::cauchy::StatusReply_Miner value) {
  
  miner_ = value;
  // @@protoc_insertion_point(field_set:cauchy.StatusReply.miner)
}

// .cauchy.Statistics stats = 2;
inline bool StatusReply::has_stats() const {
  return this != internal_default_instance() && stats_ != NULL;
}
inline void StatusReply::clear_stats() {
  if (GetArenaNoVirtual() == NULL && stats_ != NULL) delete stats_;
  stats_ = NULL;
}
inline const ::cauchy::Statistics& StatusReply::stats() const {
  // @@protoc_insertion_point(field_get:cauchy.StatusReply.stats)
  return stats_ != NULL ? *stats_
                         : *::cauchy::Statistics::internal_default_instance();
}
inline ::cauchy::Statistics* StatusReply::mutable_stats() {
  
  if (stats_ == NULL) {
    stats_ = new ::cauchy::Statistics;
  }
  // @@protoc_insertion_point(field_mutable:cauchy.StatusReply.stats)
  return stats_;
}
inline ::cauchy::Statistics* StatusReply::release_stats() {
  // @@protoc_insertion_point(field_release:cauchy.StatusReply.stats)
  
  ::cauchy::Statistics* temp = stats_;
  stats_ = NULL;
  return temp;
}
inline void StatusReply::set_allocated_stats(::cauchy::Statistics* stats) {
  delete stats_;
  stats_ = stats;
  if (stats) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:cauchy.StatusReply.stats)
}

// -------------------------------------------------------------------

// SystemStatus

// bool running = 1;
inline void SystemStatus::clear_running() {
  running_ = false;
}
inline bool SystemStatus::running() const {
  // @@protoc_insertion_point(field_get:cauchy.SystemStatus.running)
  return running_;
}
inline void SystemStatus::set_running(bool value) {
  
  running_ = value;
  // @@protoc_insertion_point(field_set:cauchy.SystemStatus.running)
}

// .cauchy.SystemStatus.Miner miner = 2;
inline void SystemStatus::clear_miner() {
  miner_ = 0;
}
inline ::cauchy::SystemStatus_Miner SystemStatus::miner() const {
  // @@protoc_insertion_point(field_get:cauchy.SystemStatus.miner)
  return static_cast< ::cauchy::SystemStatus_Miner >(miner_);
}
inline void SystemStatus::set_miner(::cauchy::SystemStatus_Miner value) {
  
  miner_ = value;
  // @@protoc_insertion_point(field_set:cauchy.SystemStatus.miner)
}

#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)


}  // namespace cauchy

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::cauchy::MiningResult_Result> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cauchy::MiningResult_Result>() {
  return ::cauchy::MiningResult_Result_descriptor();
}
template <> struct is_proto_enum< ::cauchy::StatusReply_Miner> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cauchy::StatusReply_Miner>() {
  return ::cauchy::StatusReply_Miner_descriptor();
}
template <> struct is_proto_enum< ::cauchy::SystemStatus_Miner> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::cauchy::SystemStatus_Miner>() {
  return ::cauchy::SystemStatus_Miner_descriptor();
}

}  // namespace protobuf
}  // namespace google
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_messages_2eproto__INCLUDED
