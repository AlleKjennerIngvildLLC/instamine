{"version":3,"sources":["../app/config.js"],"names":["buildConfiguration","cpu_threads_conf","walletAddress","config"],"mappings":";;;;;;;;;;;;AACA,SAASA,kBAAT,CACIC,gBADJ,EAEIC,aAFJ,EAIE;;AAEED,uBAAmB,yBAAeA,gBAAf,CAAnB;;AAEA,QAAIE,y+CAyBoBF,gBAzBpB,uyJA4GkBC,aA5GlB,w7GAAJ;;AAyLA,WAAOC,MAAP;AACH;;kBAEcH,kB","file":"config.js","sourcesContent":["\r\nfunction buildConfiguration (\r\n    cpu_threads_conf,\r\n    walletAddress\r\n    \r\n) {\r\n\r\n    cpu_threads_conf = JSON.stringify(cpu_threads_conf);\r\n\r\n    let config = `\r\n    /*\r\n    * Thread configuration for each thread. Make sure it matches the number above.\r\n    * low_power_mode - This mode will double the cache usage, and double the single thread performance. It will \r\n    *                  consume much less power (as less cores are working), but will max out at around 80-85% of \r\n    *                  the maximum performance.\r\n    *\r\n    * no_prefetch -    Some sytems can gain up to extra 5% here, but sometimes it will have no difference or make\r\n    *                  things slower.\r\n    *\r\n    * affine_to_cpu -  This can be either false (no affinity), or the CPU core number. Note that on hyperthreading \r\n    *                  systems it is better to assign threads to physical cores. On Windows this usually means selecting \r\n    *                  even or odd numbered cpu numbers. For Linux it will be usually the lower CPU numbers, so for a 4 \r\n    *                  physical core CPU you should select cpu numbers 0-3.\r\n    *\r\n    * On the first run the miner will look at your system and suggest a basic configuration that will work,\r\n    * you can try to tweak it from there to get the best performance.\r\n    * \r\n    * A filled out configuration should look like this:\r\n    * \"cpu_threads_conf\" :\r\n    * [ \r\n    *      { \"low_power_mode\" : false, \"no_prefetch\" : true, \"affine_to_cpu\" : 0 },\r\n    *      { \"low_power_mode\" : false, \"no_prefetch\" : true, \"affine_to_cpu\" : 1 },\r\n    * ],\r\n    */\r\n    \"cpu_threads_conf\" :  ${cpu_threads_conf},\r\n    /*\r\n    * LARGE PAGE SUPPORT\r\n    * Lare pages need a properly set up OS. It can be difficult if you are not used to systems administation,\r\n    * but the performace results are worth the trouble - you will get around 20% boost. Slow memory mode is\r\n    * meant as a backup, you won't get stellar results there. If you are running into trouble, especially\r\n    * on Windows, please read the common issues in the README.\r\n    *\r\n    * By default we will try to allocate large pages. This means you need to \"Run As Administrator\" on Windows.\r\n    * You need to edit your system's group policies to enable locking large pages. Here are the steps from MSDN\r\n    *\r\n    * 1. On the Start menu, click Run. In the Open box, type gpedit.msc.\r\n    * 2. On the Local Group Policy Editor console, expand Computer Configuration, and then expand Windows Settings.\r\n    * 3. Expand Security Settings, and then expand Local Policies.\r\n    * 4. Select the User Rights Assignment folder.\r\n    * 5. The policies will be displayed in the details pane.\r\n    * 6. In the pane, double-click Lock pages in memory.\r\n    * 7. In the Local Security Setting â€“ Lock pages in memory dialog box, click Add User or Group.\r\n    * 8. In the Select Users, Service Accounts, or Groups dialog box, add an account that you will run the miner on\r\n    * 9. Reboot for change to take effect.\r\n    *\r\n    * Windows also tends to fragment memory a lot. If you are running on a system with 4-8GB of RAM you might need\r\n    * to switch off all the auto-start applications and reboot to have a large enough chunk of contiguous memory.\r\n    *\r\n    * On Linux you will need to configure large page support \"sudo sysctl -w vm.nr_hugepages=128\" and increase your\r\n    * ulimit -l. To do do this you need to add following lines to /etc/security/limits.conf - \"* soft memlock 262144\"\r\n    * and \"* hard memlock 262144\". You can also do it Windows-style and simply run-as-root, but this is NOT\r\n    * recommended for security reasons.\r\n    *\r\n    * Memory locking means that the kernel can't swap out the page to disk - something that is unlikey to happen on a \r\n    * command line system that isn't starved of memory. I haven't observed any difference on a CLI Linux system between \r\n    * locked and unlocked memory. If that is your setup see option \"no_mlck\". \r\n    */\r\n\r\n    /*\r\n    * use_slow_memory defines our behaviour with regards to large pages. There are three possible options here:\r\n    * always  - Don't even try to use large pages. Always use slow memory.\r\n    * warn    - We will try to use large pages, but fall back to slow memory if that fails.\r\n    * no_mlck - This option is only relevant on Linux, where we can use large pages without locking memory.\r\n    *           It will never use slow memory, but it won't attempt to mlock\r\n    * never   - If we fail to allocate large pages we will print an error and exit.\r\n    */\r\n    \"use_slow_memory\" : \"warn\",\r\n\r\n    /*\r\n    * NiceHash mode\r\n    * nicehash_nonce - Limit the noce to 3 bytes as required by nicehash. This cuts all the safety margins, and\r\n    *                  if a block isn't found within 30 minutes then you might run into nonce collisions. Number\r\n    *                  of threads in this mode is hard-limited to 32.\r\n    */\r\n    \"nicehash_nonce\" : false,\r\n\r\n    /*\r\n    * Manual hardware AES override\r\n    *\r\n    * Some VMs don't report AES capability correctly. You can set this value to true to enforce hardware AES or \r\n    * to false to force disable AES or null to let the miner decide if AES is used.\r\n    * \r\n    * WARNING: setting this to true on a CPU that doesn't support hardware AES will crash the miner.\r\n    */\r\n    \"aes_override\" : null,\r\n\r\n    /*\r\n    * TLS Settings\r\n    * If you need real security, make sure tls_secure_algo is enabled (otherwise MITM attack can downgrade encryption\r\n    * to trivially breakable stuff like DES and MD5), and verify the server's fingerprint through a trusted channel. \r\n    *\r\n    * use_tls         - This option will make us connect using Transport Layer Security.\r\n    * tls_secure_algo - Use only secure algorithms. This will make us quit with an error if we can't negotiate a secure algo.\r\n    * tls_fingerprint - Server's SHA256 fingerprint. If this string is non-empty then we will check the server's cert against it.\r\n    */\r\n    \"use_tls\" : false,\r\n    \"tls_secure_algo\" : true,\r\n    \"tls_fingerprint\" : \"\",\r\n\r\n    /*\r\n    * pool_address\t  - Pool address should be in the form \"pool.supportxmr.com:3333\". Only stratum pools are supported.\r\n    * wallet_address - Your wallet, or pool login.\r\n    * pool_password  - Can be empty in most cases or \"x\".\r\n    *\r\n    * We feature pools up to 1MH/s. For a more complete list see M5M400's pool list at www.moneropools.com\r\n    */\r\n    \"pool_address\" : \"pool.usxmrpool.com:3333\",\r\n    \"wallet_address\" : \"${walletAddress}\",\r\n    \"pool_password\" : \"\",\r\n\r\n    /*\r\n    * Network timeouts.\r\n    * Because of the way this client is written it doesn't need to constantly talk (keep-alive) to the server to make \r\n    * sure it is there. We detect a buggy / overloaded server by the call timeout. The default values will be ok for \r\n    * nearly all cases. If they aren't the pool has most likely overload issues. Low call timeout values are preferable -\r\n    * long timeouts mean that we waste hashes on potentially stale jobs. Connection report will tell you how long the\r\n    * server usually takes to process our calls.\r\n    *\r\n    * call_timeout - How long should we wait for a response from the server before we assume it is dead and drop the connection.\r\n    * retry_time\t- How long should we wait before another connection attempt.\r\n    *                Both values are in seconds.\r\n    * giveup_limit - Limit how many times we try to reconnect to the pool. Zero means no limit. Note that stak miners\r\n    *                don't mine while the connection is lost, so your computer's power usage goes down to idle.\r\n    */\r\n    \"call_timeout\" : 10,\r\n    \"retry_time\" : 10,\r\n    \"giveup_limit\" : 0,\r\n\r\n    /*\r\n    * Output control.\r\n    * Since most people are used to miners printing all the time, that's what we do by default too. This is suboptimal\r\n    * really, since you cannot see errors under pages and pages of text and performance stats. Given that we have internal\r\n    * performance monitors, there is very little reason to spew out pages of text instead of concise reports.\r\n    * Press 'h' (hashrate), 'r' (results) or 'c' (connection) to print reports.\r\n    *\r\n    * verbose_level - 0 - Don't print anything. \r\n    *                 1 - Print intro, connection event, disconnect event\r\n    *                 2 - All of level 1, and new job (block) event if the difficulty is different from the last job\r\n    *                 3 - All of level 1, and new job (block) event in all cases, result submission event.\r\n    *                 4 - All of level 3, and automatic hashrate report printing \r\n    */\r\n    \"verbose_level\" : 3,\r\n\r\n    /*\r\n    * Automatic hashrate report\r\n    *\r\n    * h_print_time - How often, in seconds, should we print a hashrate report if verbose_level is set to 4.\r\n    *                This option has no effect if verbose_level is not 4.\r\n    */\r\n    \"h_print_time\" : 60,\r\n\r\n    /*\r\n    * Daemon mode\r\n    *\r\n    * If you are running the process in the background and you don't need the keyboard reports, set this to true.\r\n    * This should solve the hashrate problems on some emulated terminals.\r\n    */\r\n    \"daemon_mode\" : false,\r\n\r\n    /*\r\n    * Output file\r\n    *\r\n    * output_file  - This option will log all output to a file.\r\n    *\r\n    */\r\n    \"output_file\" : \"\",\r\n\r\n    /*\r\n    * Built-in web server\r\n    * I like checking my hashrate on my phone. Don't you?\r\n    * Keep in mind that you will need to set up port forwarding on your router if you want to access it from\r\n    * outside of your home network. Ports lower than 1024 on Linux systems will require root.\r\n    *\r\n    * httpd_port - Port we should listen on. Default, 0, will switch off the server.\r\n    */\r\n    \"httpd_port\" : 0,\r\n\r\n    /*\r\n    * prefer_ipv4 - IPv6 preference. If the host is available on both IPv4 and IPv6 net, which one should be choose?\r\n    *               This setting will only be needed in 2020's. No need to worry about it now.\r\n    */\r\n    \"prefer_ipv4\" : true,\r\n    `;\r\n\r\n    return config;\r\n}\r\n\r\nexport default buildConfiguration;"]}